<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Console</title>
</head>
  <script src="pixi/pixi.min.js"></script>
<body>
  <script type="text/javascript">
    let type = "WebGL"
    if(!PIXI.utils.isWebGLSupported()){
      type = "canvas"
    }

    // Keyboard related functions
    const KSPACE = 32;
    const KBACKSPACE = 8;
    const KRETURN = 13;
    const CCURSOR = String.fromCharCode(95);

	function keyboardread() {
	  key = {};
	  key.code = undefined;
	  key.press = undefined;
	  key.release = undefined;
	  //The `downHandler`123
	  key.downHandler = event => {
		key.code = event.keyCode;
        if ( ((key.code > 64) && (key.code < 91))
           ||((key.code > 47) && (key.code < 58))
           || ( key.code == KSPACE ) || (key.code == KBACKSPACE) || (key.code == KRETURN)) {
		  key.press();  
  	      event.preventDefault();
        }   
	  };
	
	  //The `upHandler`
	  key.upHandler = event => {
		key.release();
	    event.preventDefault();
	  };
	
	  //Attach event listeners
	  window.addEventListener(
	    "keydown", key.downHandler.bind(key), false
	  );
	  window.addEventListener(
	    "keyup", key.upHandler.bind(key), false
	  );
	  return key;
	}


      
    let keyreader = keyboardread();
    keyreader.press = () => {
      timerText.text = keyreader.code;
    
      if (keyreader.code == KRETURN) {
	 	PAnalyze(promptText.text);
	 	promptText.text = PS1+CCURSOR;
	 	//promptText.text = promptText.text.slice(0, promptText.text.length-1) + "\n" +CCURSOR;
	 	 	
  	  }
	  else if (keyreader.code != KBACKSPACE) {
		promptText.text = promptText.text.slice(0, promptText.text.length-1) + String.fromCharCode(keyreader.code)+CCURSOR;
      }
	  else if ((keyreader.code == KBACKSPACE) && (promptText.text.length > 3)) {
	    promptText.text = promptText.text.slice(0, promptText.text.length-2) + CCURSOR;
	  }
	  else {
      }

	
	}
      	
    // Prompt Syntax Analyser
    function PAnalyze(inputwithcursor) {
      var input = inputwithcursor.slice(2, inputwithcursor.length-1)
      consoleText.text = "## "+input+"\n";
      
      if (debugmode == 1) { // Commands in Debug mode
		  debugrequest = 0;
	      switch (input) {
			case "TIMER START":
			  timer.start();
			  consoleText.text += "## Starting Timer";
			  break;
			case "TIMER STOP":
			  timer.stop();
			  consoleText.text += "## Timer Stopped";
			  break;
			case "DEBUG OFF":
			  consoleText.text += "## Entering User mode";
			  debugmode = 0;
			  break;	    
			default:
			  consoleText.text += "## Unknown command";
		  }
		}
	  else {              // Commands in user mode	  
	      switch (input) {
			// Debug mode control
			case "DEBUG":
			  consoleText.text += "## Debug mode requested - Enter Password";
			  debugrequest = 1;
			  break;
	        case "NICK":
	          if (debugrequest == 1) {
				consoleText.text += "## Entering Debug mode";
				debugmode = 1; debugrequest == 0;
			  }
			  break;
			// User commands
			case "TIMER START":
			  timer.start();
			  consoleText.text += "## Starting Timer";
			  break;
			case "":
	          debugrequest = 0;
			  break;
			default:
			  debugrequest = 0;
			  consoleText.text += "## Unknown command";
		  }
	  }
	  
	}
    PAnalyze.prototype.get = function () {  } 	
      	
      	
      	
	let state;
	
	var app = new PIXI.Application(800, 600, {backgroundColor: 0x0});
	document.body.appendChild(app.view);
	
	var style = new PIXI.TextStyle({
	    fontFamily: 'asimov',
	    fontSize: 20,
	    fontStyle: 'normal',
	    fontWeight: 'bold',
	    fill: ['#00ff00', '#00aa00'], // gradient
	    stroke: '#4a1850',
	    strokeThickness: 0,
	    dropShadow: false,
	    dropShadowColor: '#000000',
	    dropShadowBlur: 0,
	    dropShadowAngle: 1,
	    dropShadowDistance: 6,
	    wordWrap: true,
	    wordWrapWidth: 740
	});
	var timerstyle = new PIXI.TextStyle({
	    fontFamily: 'asimov',
	    fontSize: 20,
	    fontStyle: 'normal',
	    fontWeight: 'bold',
	    fill: ['#ff0000', '#aa0000'], // gradient
	    strokeThickness: 0,
	    dropShadow: false,
	    wordWrap: true,
	    wordWrapWidth: 200
	});	
	var debugstyle = new PIXI.TextStyle({
	    fontFamily: 'asimov',
	    fontSize: 20,
	    fontStyle: 'normal',
	    fontWeight: 'bold',
	    fill: ['#00ffff', '#00aaaa'], // gradient
	    strokeThickness: 0,
	    dropShadow: false,
	    wordWrap: true,
	    wordWrapWidth: 200
	});	
	
	// Console input line
	const PS1 = "> ";
	var promptText = new PIXI.Text(PS1+CCURSOR, style);
	promptText.x = 30;
	promptText.y = 400;
	// Console output line
	var consoleText = new PIXI.Text(' ## Waiting for Command ## ', style);
	consoleText.x = 30;
	consoleText.y = 300;	
	// Upper Right field for clock and coutdown
	var timerText = new PIXI.Text('[  ]', timerstyle);
	timerText.x = 550;
	timerText.y = 40 ;
    // Upper left field for Debug Mode
    var debugText = new PIXI.Text('ZombiCorp 4.2', debugstyle);
    debugText.x = 20;
    debugText.y = 10;
	
	var timer = new Timer();
    var debugmode = 0 ; 
    var debugrequest = 0;
    // Add elements to canvas
	app.stage.addChild(promptText);
	app.stage.addChild(consoleText);
	app.stage.addChild(timerText);
	app.stage.addChild(debugText);
	   
    //Set the game state
    state = play;
 
    //Start the game loop 
    app.ticker.add(delta => gameLoop(delta));
    
	function gameLoop(delta){
	  //Update the current game state:
	  state(delta);
	  timer.init(600000);
	  //if (timer.isrunning == 0) {timer.start()};
	}
	
	// MainLoop
	function play(delta) {
	  timerText.text = "       TIME: " +heure() + " \n" + "COUNTDOWN: "+timer.get();
      if (debugmode == 1) 
		  style.fill = ['#ffff00', '#aaaa00'];
		  else style.fill = ['#00ff00', '#00aa00'];
	}
    
    // Hour function
    function heure() {
      var date = new Date();
  	  return date.getHours() + " " + date.getMinutes() + " " + date.getSeconds();
	}

    // Timer class
    function Timer() {
	  this.value = new Date(59000); // 10 minutes
	  this.isrunning = 0;
	  this.starttime = undefined;
	  this.timeout = 0;
	}
    Timer.prototype.init = function (val) { this.value.setTime(val);};
    Timer.prototype.get = function () { 
	  if (this.timeout == 1) {return -1}
	  if (this.isrunning == 0) {return this.value.getMinutes() + " " + this.value.getSeconds();}
      var currenttime = new Date();
	  var timeelapsed = new Date(currenttime - this.starttime);
	  var timeremaining = new Date(this.value - timeelapsed);
	  if (timeelapsed.valueOf() > this.value.valueOf()) {this.timeout=1; this.isrunning =1}
	  return timeremaining.getMinutes() + " " + timeremaining.getSeconds();
	}

        Timer.prototype.start = function () {
		this.isrunning = 1;
		this.timeout = 0;
		this.starttime = new Date(); // initialized with the current time
	}
        Timer.prototype.stop = function () {
		this.isrunning = 0;
	}

  </script>
</body>
</html>
