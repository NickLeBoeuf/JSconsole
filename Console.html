<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Console</title>
</head>
  <script src="pixi/pixi.min.js"></script>
<body>
  <script type="text/javascript">
    let type = "WebGL"
    if(!PIXI.utils.isWebGLSupported()){
      type = "canvas"
    }

	// Game texts
	const TEXT_LEVEL0 =    "<< Security level 0 >>";
	const TEXT_LEVEL1 =    "<< Security level 1 >>";
	const TEXT_LEVEL2 =    "<< Security level 2 >>";
	const TEXT_LEVEL3 =    "<< Security level 3 >>";
	const TEXT_LEVEL4 =    "<< Security level 4 >>";
	const TEXT_LEVEL5 =    "<< Security level 5 >>";
	const TEXT_LEVEL6 =    "<< Security level 6 >>";
	const TEXT_LEVEL7 =    "<< Security level 7 >>";
	const TEXT_PROMPT =    "## Enter password to raise Security Level\n";
    const TEXT_UNKNOWN =   "## Unknown password / command ";
	const TEXT_TIMERSTART= "## Starting Timer";
	const TEXT_TIMERSTOP=  "## Timer Stopped";
	const TEXT_TIMERRESET= "## Timer has been reset";
	const TEXT_USERMODE=   "## Entering User mode";
	const TEXT_DEBUGREQ=   "## Debug mode requested - Enter Password";
    const TEXT_DEBUGENTRY= "## Password correct\n## Entering Debug mode";				  

    function gameprogress() {
	  this.level = TEXT_LEVEL0;
	}
	gameprogress.prototype.getstring = function () {
	  switch (this.level) {
		  case 0: return TEXT_LEVEL0;
		  case 1: return TEXT_LEVEL1;
		  case 2: return TEXT_LEVEL2;
		  case 3: return TEXT_LEVEL3;
		  case 4: return TEXT_LEVEL4;
		  case 5: return TEXT_LEVEL5;
		  case 6: return TEXT_LEVEL6;
		  case 7: return TEXT_LEVEL7;
		  default : return TEXT_LEVEL7;
		}
	}
	
	
	
    // Hour function
    function heure() {
      var date = new Date();
  	  return date.getHours() + " " + date.getMinutes() + " " + date.getSeconds();
	}
	
    // Keyboard related functions  /////////////////////////////////////
    const KSPACE = 32;
    const KBACKSPACE = 8;
    const KRETURN = 13;
    const KUPARROW = 38;
    const KDOWNARROW = 40;
    const CCURSOR = String.fromCharCode(95);

	function keyboardread() {
	  key = {};
	  key.code = undefined;
	  key.press = undefined;
	  key.release = undefined;
	  //The `downHandler`
	  key.downHandler = event => {
		key.code = event.keyCode;
        if ( ((key.code > 64) && (key.code < 91))
           ||((key.code > 47) && (key.code < 58))
           ||((key.code > 37) && (key.code < 41))
           || ( key.code == KSPACE ) || (key.code == KBACKSPACE) || (key.code == KRETURN)) {
		  key.press();  
  	      event.preventDefault();
        }   
	  };
	  //The `upHandler`
	  key.upHandler = event => {
		key.release();
	    event.preventDefault();
	  };
	  //Attach event listeners
	  window.addEventListener(
	    "keydown", key.downHandler.bind(key), false
	  );
	  window.addEventListener(
	    "keyup", key.upHandler.bind(key), false
	  );
	  return key;
	}

    // Timer class /////////////////////////////////////////////////////
    const MAXTIMER = 15000;
    function Timer() {
	  this.maxvalue = new Date(MAXTIMER); 
	  this.currentvalue = this.maxvalue;
	  this.laststartvalue = this.maxvalue;
	  this.isrunning = 0;
	  this.starttime = undefined;
	  this.timeout = 0;
	}
    Timer.prototype.init = function (val) {
	  this.maxvalue.setTime(val);
      this.currentvalue=this.maxvalue;
	  this.laststartvalue = this.maxvalue;
      this.timeout = 0;
      this.isrunning = 0;
      };
    Timer.prototype.get = function () { 
	  if (this.timeout == 1) {return -1}
	  if (this.isrunning == 0) {return this.currentvalue.getMinutes() + " " + this.currentvalue.getSeconds();}
      var currenttime = new Date();
	  var timeelapsed = new Date(currenttime - this.starttime);
	  this.currentvalue = new Date(this.laststartvalue - timeelapsed);
	  if (this.currentvalue.valueOf() < 999) {this.timeout=1; this.isrunning =1}
	  return this.currentvalue.getMinutes() + " " + this.currentvalue.getSeconds();
	}
    Timer.prototype.start = function () {
		if (this.isrunning ==0) {
			this.isrunning = 1;	
			this.starttime = new Date(); // initialized with the current time
		} // else no action
	}
    Timer.prototype.stop = function () {
		this.isrunning = 0;
		this.laststartvalue = this.currentvalue;
	}      	
      

      	
    // Prompt Syntax Analyser  /////////////////////////////////////////
    // Debug mode password is:
    const DEBUGPASSWD="NICK";
    function PAnalyze() {
	  this.lastcommand = "";
	}
	
    PAnalyze.prototype.command = function(inputwithcursor) {
      var input = inputwithcursor.slice(2, inputwithcursor.length-1)
      consoleText.text = TEXT_PROMPT + "## "+input+"\n";
      this.lastcommand = input;
      // Debug mode entry control
      if ((debugrequest == 1) && (input == DEBUGPASSWD)) {
		consoleText.text = TEXT_DEBUGENTRY;
		debugmode = 1; debugrequest == 0; this.lastcommand ="";
	  }
	  // Analyze Commands
	  else {
	      if (debugmode == 1) { // Commands in Debug mode
			  debugrequest = 0;
		      switch (input) {
				case "TIMER START":
				  timer.start(MAXTIMER);
				  consoleText.text += TEXT_TIMERSTART;
				  break;
				case "TIMER STOP":
				  timer.stop();
				  consoleText.text += TEXT_TIMERSTOP;
				  break;
				case "TIMER RESET":
				  timer.init(MAXTIMER);
				  consoleText.text += TEXT_TIMERRESET;
				  break;
				case "DEBUG OFF":
				  consoleText.text += TEXT_USERMODE;
				  debugmode = 0;
				  break;	    
				default:
				  consoleText.text += TEXT_UNKNOWN;
			  }
			}
		  else {              // Commands in user mode	  
		      switch (input) {
				// Debug mode control
				case "DEBUG":
				  consoleText.text += TEXT_DEBUGREQ;
				  debugrequest = 1;
				  break;
				// User commands
				case "TIMER START":
				  timer.start();
				  consoleText.text += TEXT_TIMERSTART;
				  break;
				case "":
		          debugrequest = 0;
				  break;
				default:
				  debugrequest = 0;
				  consoleText.text += TEXT_UNKNOWN;
			  }
		  }
	  }
	}
    PAnalyze.prototype.get = function () {  } 	
      	
      	
      	
	

    // KEYBOARD READER /////////////////////////////////////////////////
    let keyreader = keyboardread();
    keyreader.press = () => {
      timerText.text = keyreader.code;
      if (keyreader.code == KRETURN) {
	 	//PAnalyze(promptText.text);
	 	console.command(promptText.text);
	 	promptText.text = PS1+CCURSOR; 	 	
  	  }
  	  else if (keyreader.code == KUPARROW) {
		promptText.text = PS1+console.lastcommand+CCURSOR;
	  }
	  else if (keyreader.code == KDOWNARROW) {
		promptText.text = PS1+CCURSOR;
	  }
	  else if (keyreader.code != KBACKSPACE) {
		promptText.text = promptText.text.slice(0, promptText.text.length-1) + String.fromCharCode(keyreader.code)+CCURSOR;
      }
	  else if ((keyreader.code == KBACKSPACE) && (promptText.text.length > 3)) {
	    promptText.text = promptText.text.slice(0, promptText.text.length-2) + CCURSOR;
	  }
	  else {
      }
	}

      	
	let state;
	
	var app = new PIXI.Application(800, 600, {backgroundColor: 0x0});
	document.body.appendChild(app.view);
	
	var style = new PIXI.TextStyle({
	    fontFamily: 'asimov',
	    fontSize: 20,
	    fontStyle: 'normal',
	    fontWeight: 'bold',
	    fill: ['#00ff00', '#00aa00'], // gradient
	    stroke: '#4a1850',
	    strokeThickness: 0,
	    dropShadow: false,
	    dropShadowColor: '#000000',
	    dropShadowBlur: 0,
	    dropShadowAngle: 1,
	    dropShadowDistance: 6,
	    wordWrap: true,
	    wordWrapWidth: 740
	});
	var timerstyle = new PIXI.TextStyle({
	    fontFamily: 'asimov',
	    fontSize: 20,
	    fontStyle: 'normal',
	    fontWeight: 'bold',
	    fill: ['#ff0000', '#aa0000'], // gradient
	    strokeThickness: 0,
	    dropShadow: false,
	    wordWrap: true,
	    wordWrapWidth: 200
	});	
	var debugstyle = new PIXI.TextStyle({
	    fontFamily: 'asimov',
	    fontSize: 20,
	    fontStyle: 'normal',
	    fontWeight: 'bold',
	    fill: ['#00ffff', '#00aaaa'], // gradient
	    strokeThickness: 0,
	    dropShadow: false,
	    wordWrap: true,
	    wordWrapWidth: 200
	});	
	var infostyle = new PIXI.TextStyle({
	    fontFamily: 'asimov',
	    fontSize: 30,
	    fontStyle: 'normal',
	    fontWeight: 'bold',
	    fill: ['#00ffff', '#00aaaa'], // gradient
	    strokeThickness: 0,
	    dropShadow: false,
	    wordWrap: true,
	    wordWrapWidth: 540
	});	
	// Console input line
	const PS1 = "> ";
	var promptText = new PIXI.Text(PS1+CCURSOR, style);
	promptText.x = 30;
	promptText.y = 400;
	// Console output line
	var consoleText = new PIXI.Text(TEXT_PROMPT, style);
	consoleText.x = 30;
	consoleText.y = 300;	
	// Upper Right field for clock and coutdown
	var timerText = new PIXI.Text('[  ]', timerstyle);
	timerText.x = 550;
	timerText.y = 40 ;
    // Upper left field for Debug Mode
    var debugText = new PIXI.Text('ZombiCorp 4.2', debugstyle);
    debugText.x = 20;
    debugText.y = 10;
    // Middle field for Security Level indicator
    var securitylevelText = new PIXI.Text(TEXT_LEVEL0, infostyle);
    securitylevelText.x = 130;
    securitylevelText.y = 150;
	
	var timer = new Timer();
	var console = new PAnalyze();
    var debugmode = 0 ; 
    var debugrequest = 0;
    var securitylevel = new gameprogress();securitylevel.level = 0;
    
    // Add elements to canvas
	app.stage.addChild(promptText);
	app.stage.addChild(consoleText);
	app.stage.addChild(timerText);
	app.stage.addChild(debugText);
	app.stage.addChild(securitylevelText);
	
	// init timer
	timer.init(MAXTIMER);   

    //Set the game state
    state = play;
 
    //Start the game loop 
    app.ticker.add(delta => gameLoop(delta));
    
	function gameLoop(delta){
	  //Update the current game state:
	  state(delta);
//	  debugText.text = debugText.text + "1";
	}
	
	// MainLoop
	function play(delta) {
	  var time = new Date();
	  timerText.text = "       TIME: " + heure() + " \n" + "COUNTDOWN: "+timer.get();
	  if ((time % 2000) > 1800) {securitylevelText.text = "";} else {securitylevelText.text=securitylevel.getstring();}
	  
	  if (debugmode == 1) {
		  style.fill = ['#ffff00', '#aaaa00'];
		  timerText.text += "\nKEY CODE: "+keyreader.code;
	  }
		  else style.fill = ['#00ff00', '#00aa00'];
	}
    




  </script>
</body>
</html>
